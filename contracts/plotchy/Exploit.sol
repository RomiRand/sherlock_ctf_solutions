//SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import './Setup.sol';
import 'hardhat/console.sol';

contract Exploit {
    constructor(AmusementPark challenge) {

        test();
        bytes[] memory mirrors = new bytes[](4);


        bytes[] memory roller = new bytes[](2); // 0 2 0 1 4 3 1 5
        uint r;
        r ^= 5;
        r <<= 3;
        r ^= 1;
        r <<= 3;
        r ^= 3;
        r <<= 3;
        r ^= 4;
        r <<= 3;
        r ^= 1;
        r <<= 3;
        r ^= 0;
        r <<= 3;
        r ^= 2;
        r <<= 3;
        r ^= 0;
        roller[0] = abi.encodePacked(r);
        roller[1] = abi.encodeCall(challenge._HouseOfMirrors, (mirrors));
        bytes memory rollercoaster = abi.encodeCall(challenge._Rollercoaster, (roller));
        // what the actual f. I've no idea why.. this took me forever.
        // I wasn't able to do this with normal abi.encode*** calls, for some reason the decoding of the bytes type didn't work
        // needed to rebuild the bytes type: the first 2*32 bytes describe some offset + length
        // The offset is 0x0..020, but should be 0x0..040 instead
        // please tell me I'm missing something here -_-
        bytes memory yellowCar = bytes.concat(bytes23(uint184(1)), bytes32(uint(0x40)), bytes32(rollercoaster.length), rollercoaster);
        bytes memory prev = reverseBytes(abi.encodeCall(challenge._BumperCars, ("blue", uint40(bytes5(bytes.concat("255", "0", "0"))), yellowCar)));
        bytes memory ticket = abi.encodeCall(challenge._Carousel, (prev));
        challenge.parkEntrance(ticket);   
    }
    
    function reverseBytes(bytes memory data) public pure returns (bytes memory)
    {
        bytes memory value;
        for(uint s = data.length; s > 0; s--) {
            value = bytes.concat(value, data[s-1]);
        }
        return value;
    }

    function test() public {
        uint a;
        if ( a++ == 0 || true)
        {

        }
        console.log(a);

    }
}
